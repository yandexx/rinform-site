# Список свойств

Ниже идёт список всех свойств (properties) из стандартной библиотеки.

Свойства объекта — это какие-то данные или код, ассоциированный с объектом. Кроме стандартных свойств можно свободно добавлять свои.

## `n_to`, `s_to`, `e_to`, `w_to`…

  Только для комнат. Также есть **ne_to**, **nw_to**, **se_to**, **sw_to**, **in_to**, **out_to**, **u_to** и **d_to**.

  Соответственно это направления на север, юг, восток, запад, СВ, СЗ, ЮВ, ЮЗ, внутрь, наружу, вверх и вниз.

  Значением свойства может быть: 
  * `false` (по умолчанию), что означает что выхода нет;
  * строка, которая пояснит игроку, почему выхода в этом направлении нет;
  * комната, либо дверь, в которую будет вести выбранное направление из текущей комнаты;
  * процедура, которая вернёт что-либо из выше перечисленного.

  ```
  Object At_Top_Of_Small_Pit "Над колодцем"
  with description
  "Прямо из ваших ног находится колодец, буквально дышащий белым туманом.
   В этом месте проход на запад кончается, если не считать очень узкую трещину.^
   Грубые каменные ступени дают возможность спуститься вниз.",
       e_to In_Bird_Chamber,
       w_to "Трещина слишком узка, чтобы в нее протиснуться.",
       d_to
       [; if (large_gold_nugget in player)
          {   deadflag=1;
              "Вы достигли дна колодца быстрее, чем сами хотели,
               и лежите там со сломанной шеей.";
          }
          return In_Hall_Of_Mists;
       ],
  ...
  ```

## `add_to_scope`

  Если текущий объект находится в области видимости (scope), то все объекты, перечисленные в этом свойстве, тоже попадут в область видимости. Если делать это через процедуру, то она должна вызвать `PlaceInScope(объект)`, чтобы поместить `объект` в область видимости.

## `article` и `articles`

  Артикли для объектов. В русской версии не требуются. 

## `after`
 
  Сюда попадают все действия *после того*, как они произошли, но ещё до того, как об этом было сказано игроку.

  Для объекта: все действия, происходящие с данным объектом.

  Для комнаты: все действия, происходящие в этой комнате.

  Если код вернёт `false`, выполнение продолжится, и выведется текст о том, что произошло. Если `true`, то выполнение на этом остановится, текста выведено не будет.

  Так можно заменить текст стандартных реакций на свой:

  ```
  Object -> RustyDoor "ржав/ая железн/ая двер/ь"
  with name 'больш' 'ржав' 'железн' 'двер' 'петл',
      ...
      after
      [; 
          Open: "Дверь отворилась с жутким скрипом и дождем из осыпающейся ржавчины.";
      ],
  has static door locked female;
  ```

  Или, например, сделать что-то дополнительное к действию:

  ```
  Object top_of_tree "На верхушке дерева"
  with description "На этой высоте цепляться за ствол уже не так удобно.",
      d_to clearing,
      after [;
          Drop:
              move noun to clearing;
              return false;
      ],
  has light;
  ```

## `before`

  Сюда попадают все действия после ввода команды, но ещё *до того*, как они произошли.

  Так можно перехватить действие и объяснить игроку, почему оно невозможно, или выполнить какую-то другую логику.

  Для объекта: все действия, происходящие с данным объектом.

  Для комнаты: все действия, происходящие в этой комнате.

  Если код вернёт `false`, то выполнение продолжится. Если `true`, то выполнение на этом остановится (действие не произойдёт).

  ```
  Treasure -> "персидск/ий ков/е/р/"
  with name 'персидск' 'ковер' 'ковр',
       before
       [; Take: if (Dragon in location)
                "То, что на ковре развалился здоровенный (и весьма свирепый) дракон,
                 немного мешает реализации этой привлекательной идеи.";
       ],
  ...
  ```

## `cant_go`

  Свойство для комнаты, содержащее строку, либо процедуру, которая выведет строку при попытке пойти в несуществующем направлении. По умолчанию: «Этот путь недоступен».

  ```
  Object before_cottage "Перед домом"
      with description
              "Ты стоишь около избушки, на восток от которой раскинулся лес.",
          e_to forest,
          cant_go "Единственный путь ведет на восток.",
      has light;
  ```

## `capacity`

  Для `container` или `supporter`-объектов — максимальное количество объектов, которые в или на объект можно поместить. По умолчанию — 100. Для игрока — максимальное количество объектов, которое можно удержать. Для изначального игрока (`selfobj`) это значение выставляется через `MAX_CARRIED`.

## `daemon`

  После активации через `StartDaemon(объект)`, эта процедура будет вызываться один раз каждый ход до тех пор, пока не будет остановлена через `StopDaemon(объект)`.

  Это хорошо подходит для моделирования NPC, автономных систем, механизмов и т.д.

  ```
  Object -> Bear "огромн/ый пещерн/ый медвед/ь"
  with ...,
      daemon [; 
          if (location==thedark) rfalse;
          if (self in location) {
              if (location==At_Breath_Taking_View)
                  "^Медведь у Вас за спиной восторженно взревел!";
              rfalse;
          }
          move self to location;
          "^Медведь неотступно следует за Вами.";
      ],
  ...
  ```

## `describe`

  Вызывается перед тем, как объект будет выведен в комнате. Если это свойство задано у комнаты, то вызывается перед выводом описания комнаты.

  Если `describe` вернёт:
  * `false`, то выполнение продолжится, и выведется стандартное описание.
  * `true`, то на этом выполнение остановится, дальнейшего вывода текста не будет.

  ```
  Treasure -> "персидск/ий ков/е/р/"
  with name 'персидск' 'ковер' 'ковр',
  ...
  describe [;
      if (Dragon in location)
          "Дракон лежит на роскошном персидском ковре!";
      "Пол пещеры покрыт роскошным персидским ковром.";
  ],
  ...
  ```

## `description`

  Для объекта: описание объекта, которое выводится при осмотре объекта игроком.

  Для комнаты: описание комнаты.

  Описание может быть строкой или может быть сгенерировано процедурой.

  ```
  Object  hook "маленьк/ий бронзов/ый крюч/о/к/" cloakroom
  with  name 'маленьк' 'бронзов' 'крюк' 'крючок' 'крючк' 'вешалк',
  ...
  description [;
      print "Всего лишь маленький бронзовый крючок для одежды, ";
      if (self == parent(cloak)) "с которого свисает черный бархатный плащ.";
      "привинченный к стене.";
  ],
  has scenery supporter male;
  ```

## `door_dir`

  Это свойство должно возвращать направление, в котором ведёт данная дверь. Например, если мост ведёт на восток, то нужно вернуть `e_to`.

  ```
  Object CrystalBridge "хрустальн/ый мост/"
  with name 'волшебн' 'хрустальн' 'мост',
      initial "Оба края пропасти теперь соединяет хрустальный мост.",
      ...
      door_dir [; 
          if (location==West_Side_Of_Fissure) return e_to;
          return w_to;
      ],
      ...
  ```

## `door_to`

  Это свойство должно вернуть, куда (в какую локацию) ведёт дверь.

  Можно вернуть:
  * `false` (по умолчанию), что означает что дверь ведёт никуда;
  * строка, которая пояснит игроку, почему дверь ведёт никуда;
  * объект комнаты, в которую должна вести дверь;
  * процедура, которая вернёт что-либо из выше перечисленного.

  ```
  Object CrystalBridge "хрустальн/ый мост/"
  with name 'волшебн' 'хрустальн' 'мост',
      initial "Оба края пропасти теперь соединяет хрустальный мост.",
      ...
      door_to [;
          if (location==West_Side_Of_Fissure) return On_East_Bank_Of_Fissure;
          return West_Side_Of_Fissure;
      ],
      ...
  ```

## `each_turn`

  Текст или процедура, которые будут выполняться (выводиться) в конце каждого хода (после всех демонов (daemons) и таймеров), если объект находится в зоне видимости.

  ```
  Object branch "надежн/ый толст/ый сук/" top_of_tree
    with ...
        each_turn [; if (bird in nest && nest in branch) deadflag = 2; ],
    ...
  ```

## `found_in`

  Объект будет присутствовать во всех комнатах, перечисленных через пробел в этом свойстве. Если указать не комнату, а обычный объект, то будет присутствовать в той же комнате, что указанный объект.

  Так можно удобно моделировать, например, небо, солнце и любые другие объекты, которые должны присутствовать в нескольких местах.

  Можно написать процедуру, которая будет это решать. Процедуре нужно оценить переменную `location` и вернуть `true`, если объект должен присутствовать, или `false` в противном случае.

  Обратите внимание, что свойство проверяется *только* в момент перехода из одной комнаты в другую. Также, свойство перестаёт работать для объектов с атрибутом `absent`.

  ```
  Prop "Солдат/ы Гесслера"
      with ...,
      found_in south_square mid_square north_square marketplace,
  has animate pluralname;
  ```

## `grammar`

  Только для объектов `animate` или `talkable`. Только для приказов (`> Антон, отдай мне бутерброд`). Вызывается тогда, когда парсер определил глагол (`verb_word`) и положение глагола в команде (`verb_wordnum`) при обращении к кому-то, но ещё не попробовал применить эту грамматику. 

  Необходимо вернуть один из вариантов:
  * `false`, чтобы библиотека продолжила выполнение;
  * `true`, чтобы на этом остановить выполнение и таким образом указать, что ваш код сделал все нужные действия самостоятельно: выставил `action`, `noun`, `second`;
  * словарное слово глагола, например `'бр'` («брать»), чтобы библиотека использовала грамматику этого глагола;
  * или минус с глаголом, `-'бр'`, чтобы библиотека использовала грамматику этого глагола, а затем ещё и стандартную.

## `initial`

  Описание объекта, который ещё не был подобран — то есть изначальное описание в комнате, где он лежит. Это может быть как строка, так и процедура.

  Для комнаты такое свойство вызывается или выводится, когда игрок в неё заходит.

  ```
  Object -> black_rod "черн/ый жезл/ со ржавой звездой на конце"
  with name 'черн' 'ржав' 'жезл' 'звезд',
      initial "Трехфутовый черный жезл, один конец которого украшает 
               ржавая железная звезда, лежит у Ваших ног.",
      description "Черный жезл длиной в три фута, со звездой на конце.",
  ...
  ```

## `inside_description`

  Описание объекта, выводящееся, когда игрок находится внутри него. Такой объект должен иметь атрибут `enterable`.

  ```
  Object -> cage "железн/ая клетк/а"
  with  name 'железн' 'клетк' 'прут' 'решетк' 'знак',
      description
          "Символы на клетке таковы: Птица, Стрела, Вепрь.",
      inside_description [;
          if (self.floor_open)
              "Узкая нора в земляном полу клетки открывает путь вниз,
               в погребальный колодец.";
          "Толстые прутья железной решетки окружают вас со всех сторон.";
          ],
  ...
  has enterable transparent container openable open static female;
  ```

## `invent`

  Это свойство позволяет изменять то, как выводится объект в инвентаре.

  Оно вызывается дважды:
  * сначала никакой текст в инвентаре про этот объект выведен не был, и `inventory_stage` равно **1**.

    Здесь можно удобно и любым способом изменить вывод текста в инвентаре. После чего нужно вернуть `false`, чтобы продолжить, или `true` чтобы на этом закончить.

  * затем выведется короткое (обычное) имя объекта, и будет второй вызов, где `inventory_stage` равно **2**.

    Уточняющие детали вида «(открыт)» или «(пуст)» на этот момент ещё не вывелись, и здесь можно вывести свой текст, например «(висит набекрень)».

    Здесь аналогично нужно вернуть `false`, чтобы продолжить, или `true` чтобы на этом закончить.

  ```
  Object  your_candle "свеч/а"
  ...
  invent [;
      if (sin_shadow.evil == true) {
          if (self.lit == true) {
              print "свеча (горит)"; rtrue;
          }
          else
              print "свеча"; rtrue;
      }
      if (self.lit == true) {
          print "твоя свеча (горит)"; rtrue;
      }
      else
          print "твоя свеча"; rtrue;
    ],
  ...
  ```

## `life`

  Здесь нужно перечислять правила для `animate` объектов. Работают они так же, как `before` или `after`, но только для следующих действий:

  `Attack Kiss WakeOther ThrowAt Give Show Ask Tell Answer Order`

  Если код вернёт `false`, выполнение продолжится, и выведется текст о том, что произошло. Если `true`, то выполнение на этом остановится, текста выведено не будет.

  ```
  Object cecilia1 "девушк/а"
  ...
      life [;
        WakeOther:
            if (self.woken == false)
                "Ты осторожно толкаешь её, но она спит слишком крепко.";
            else
                "Не нужно.";
      ...
  ```

## `list_together`

Объекты с одинаковым свойством `list_together` будут сгруппированы при выводе в инвентаре или в комнате.

Свойство может быть:
* числом — все объекты с одинаковым числом группируются;
* строкой — все объекты с одинаковой строкой группируются;
* процедурой.

  Такая процедура будет вызвана дважды:
  * первый раз до вывода текста и с `inventory_stage` равным **1**. Здесь нужно вернуть `false`, чтобы продолжить, или `true` чтобы на этом закончить.
  * второй раз после вывода группы предметов и с `inventory_stage` равным **2**. Возвращать значения не требуется.

```
Constant KEYS_GROUP = "ключа";

Object gold_key "золот/ой ключ/"
with name "золот" "ключ",
list_together KEYS_GROUP,
has male;

Object silver_key "серебрян/ый ключ/"
with name "серебрян" "ключ",
list_together KEYS_GROUP,
has male;

Object bronze_key "бронзов/ый ключ/"
with name "бронзов" "ключ",
list_together KEYS_GROUP,
has male;
``` 

```
> ИНВЕНТАРЬ
У тебя с собой есть:
  три ключа:
    бронзовый ключ
    серебряный ключ
    золотой ключ
```

## `name`

Список словарных слов, относящихся к данному объекту. Это именно те слова, по которым игрок обращается к объектам вокруг.

Если такое свойство есть у комнаты, то при обращении будет выведено «Упоминать это в игре нет необходимости».

Если у объекта есть свойство `parse_name`, то оно рассматривается в приоритете.

```
Prop "прилавк/и"
    with name 'прилавк' 'ларьк' 'ларёк' 'ряд',
    description "Еда, инструменты, одежда — обычное барахло.",
    found_in street below_square,
has  pluralname;
```

## `number`

Свойство для произвольного использования, в котором можно хранить любое численное значение. Исторически это осталось со старых версий Информа, сейчас же можно создавать свои собственные свойства для этих целей.

## `orders`

Только для объектов `animate` или `talkable`. Обрабатывает приказы от игрока вида `> РОБОТ, ПОДМЕТИ КОМНАТУ`.

Указанное в приказе действие и объекты, с которым его нужно совершить, будут соответственно в переменных `action`, `noun` и `second`.

Нужно вернуть `false`, чтобы продолжить, или `true` чтобы закончить.

```
Object  priest "мумифицированн/ый жрец/"
...
    orders [;
        Go:
            "~Нет, мне нельзя покидать Гробницу.~";
        NotUnderstood:
            "~Говоришь загадками?~";
        default:
            "~Не твоим приказам я служу, пришелец.~";
    ],
has animate male;
```

## `parse_name`

Процедура, которая будет обрабатывать название объекта. Используется для сложных случаев, где `name` может быть недостаточно. Вызывается до просмотра `name`.

Процедуре следует пройти по всем словам, вызывая `NextWord()`. В конце нужно вернуть:
* **0**, если введённые слова никак не относятся к объекту;
* **-1**, чтобы парсер продолжил выполнение и просто использовал список из `name`;
* или количество слов подряд, которые подошли.

```
Object  chess_pieces "шахматн/ые фигур/ы" Drawing_Room
 has    scenery pluralname
 with   parse_name [ w colour n;
            w = NextWord();
            if (w == 'белый' or 'черный') {
                n ++;
                colour = w;
                w = NextWord();
            }
            if (w == 'пешка' or 'ладья' or 'тура' ||
                w == 'конь' or 'слон' or 'офицер' ||
                w == 'король' || (w == 'королева' && 
                (colour == 'белая' || rug hasnt general))) return n + 1;
            return 0;
        ], 
```

## `plural`

Имя объекта во множественном числе. Используется для вывода, только если рядом находятся несколько таких объектов.

```
Class GoldCoin
    with name 'золот' 'монет',
    short_name "золотая монета",
    plural "золотые монеты";

Object bag "сумк/а"
    with name 'сумк',
has container open openable female;

GoldCoin ->;
GoldCoin ->;
GoldCoin ->;
```

```
> ИНВЕНТАРЬ
У тебя с собой есть:
  сумка (открыта)
    три золотые монеты
```

## `react_after`

Работает так же, как `after`, но перехватывает все действия поблизости, то есть все, где этот объект находится в области видимости. Код выполнится после завершения действия, но до того, как об этом было сказано игроку.

Нужно вернуть `true`, чтобы на этом закончить, или `false`, чтобы продолжить.

```
Object -> psychiatrist "бородат/ый психиатр/"
with name 'бородат' 'борода' 'психиатр' 'психолог',
...
react_after [;
    Insert: print "«Пациент ассоциирует ", (cAcc) noun, " с ",
        (cIns) second, ". Любопытно».^^";
    PutOn: print "«Пациент кладёт ", (cAcc) noun, " на ",
        (cAcc) second, ". Любопытно».^^";
    Look: print "^«Представьте, что меня здесь нет».^^";
],
...
has animate male;
```

## `react_before`

Работает так же, как `before`, но перехватывает все действия поблизости, то есть все, где этот объект находится в области видимости. Код выполнится до совершения действия.

Нужно вернуть `true`, чтобы остановить действие, или `false`, чтобы продолжить.

```
Object -> gocage "клетк/а"
...
react_before [;
    Exit:
        if (player in self) {
            if (self hasnt open)
                "Ты не сможешь выйти из клетки, пока крышка люка закрыта.";
            move player to parent(self);
            if (keep_silent == 0)
                print "Ты сходишь с платформы.^";
            rtrue;
        } 
...
```

## `short_name`

Альтернативное, расширенное название объекта. Может быть строкой или процедурой. Так можно динамически менять выводимое имя объекта.

Если вернуть `false`, то далее выведется оригинальное название объекта. Если `true`, то вывод прекратится.

```
NPC   cellar_figure
with  short_name [;
    if (self.unmasked == true) {
        print "Игнат"; rtrue;
    }
    else
        print "фигура"; rtrue;
    ],
...
```

## `short_name_indef`

В русской версии не используется.

## `time_left`

Количество ходов, оставшееся до срабатывания таймера данного объекта. Таймер нужно установить заранее через `StartTimer(obj)`. Изначальное значение не важно, и оно будет перезаписано запущенным таймером, но свойство тем не менее нужно добавить.

Если значение сейчас равно 0, то таймер сработает в конце этого хода. Если 1, то в конце следующего, и т.д.



## `time_out`

Процедура, код, который надо выполнить при срабатывании таймера. Таймер нужно установить заранее через `StartTimer(obj)`. Свойство `time_left` тоже необходимо добавить.

```
Object clock "будильник"
...
    time_left,
    time_out [;
        "^Раздаётся резкий звон будильника.";
    ],
...
```

## `when_closed` и `when_open`

Для дверей и контейнеров (`container`): строка или процедура, описывающие объект в комнате, когда этот объект **закрыт** или, соответственно, **открыт**.

```
Object girlroom_door "двер/ь" girlroom
   with name 'щеколд' 'двер' 'деревян',
       description "Это простая деревянная дверь, запирающаяся изнутри на щеколду.",
       when_open   "Дверь на востоке - это единственный выход из комнаты. Сейчас она приоткрыта.",
       when_closed "Единственный выход из комнаты - это закрытая дверь на востоке.",
...
```

## `when_off` и `when_on`

Для выключаемых объектов (с атрибутом `switchable`): строка или процедура, описывающие объект в комнате, когда этот объект **выключен** или, соответственно, **включен**.

```
Object -> brass_lantern "латунн/ая ламп/а"
  with name 'латунн' 'ламп' 'фонар' 'светильник',
       when_on  "Ваша лампа поблизости испускает яркий свет.",
       when_off "Рядом тускло поблескивает лампа из латуни.",
...
has switchable female;
```

## `with_key`

Для запираемых объектов (с атрибутом `lockable`) здесь нужно указать другой объект, который будет ключом для данного объекта. Если указать **0** или `nothing`, то подходящего ключа не будет вообще (хотя игроку явно об этом сказано не будет).

```
Object  hatch_lock "зам/о/к/ люка"
with  pname 'люк' 'замок' 'замк',
    description "Константин хотел убедиться, что братья едят только положенные порции,
    и потому настоял на том, чтобы запереть подвал. Он никогда не давал тебе ключ.",
    ...
    with_key cellar_key,
has scenery lockable locked male;
```